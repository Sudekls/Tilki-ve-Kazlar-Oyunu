<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tilki ve Kazlar Oyunu</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }

    body{
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      min-height:100vh; background:linear-gradient(135deg,#1e3c72,#2a5298); color:white; padding:20px;
    }

    .container{
      background-color:rgba(255,255,255,0.1);
      backdrop-filter:blur(10px);
      border-radius:15px;
      padding:30px;
      max-width:800px;
      width:100%;
      box-shadow:0 10px 25px rgba(0,0,0,0.3);
      text-align:center;
    }

    h1{ margin-bottom:15px; color:white; text-shadow:2px 2px 4px rgba(0,0,0,0.3); }

    .player-selection{ display:flex; justify-content:center; gap:20px; margin-bottom:20px; }
    .player-btn{
      padding:12px 25px; background-color:#6c757d; color:white; border:none; border-radius:50px;
      cursor:pointer; font-size:1rem; font-weight:bold; transition:all .3s ease;
    }
    .player-btn.active{ background-color:#4CAF50; }
    .player-btn:hover{ transform:translateY(-2px); }

    .game-info{
      display:flex; justify-content:space-around; margin-bottom:20px;
      background-color:rgba(255,255,255,0.2); padding:15px; border-radius:10px;
    }
    .info-item{ display:flex; flex-direction:column; align-items:center; }
    .info-label{ font-size:.9rem; opacity:.8; }
    .info-value{ font-size:1.5rem; font-weight:bold; }

    .board-container{ display:flex; justify-content:center; margin-bottom:20px; }

    .board{
      display:grid; grid-template-columns:repeat(7,1fr); grid-template-rows:repeat(7,1fr);
      width:500px; height:500px; background-color:#DEB887; border:8px solid #8B4513;
      border-radius:5px; position:relative;
    }

    .cell{ display:flex; align-items:center; justify-content:center; position:relative; cursor:pointer; }

    .cell.active::before{
      content:''; position:absolute; width:85%; height:85%; background-color:#8B4513;
      border-radius:50%; z-index:1;
    }

    .cell.valid::before{ background-color:rgba(144,238,144,0.7); }
    .cell.capture::before{ background-color:rgba(255,0,0,0.5); }
    .cell.highlight::before{
      background-color:rgba(255,215,0,0.7);
      animation:pulse 1s infinite;
    }

    @keyframes pulse{
      0%{ transform:scale(1); }
      50%{ transform:scale(1.1); }
      100%{ transform:scale(1); }
    }

    .piece{
      width:40px; height:40px; border-radius:50%; position:relative; z-index:2;
      box-shadow:0 3px 6px rgba(0,0,0,0.3); transition:all .3s ease;
    }
    .fox{ background:radial-gradient(circle at 30% 30%,#FF6B35,#C44536); border:2px solid #8B4513; }
    .goose{ background:radial-gradient(circle at 30% 30%,#FFFFFF,#B0B0B0); border:2px solid #8B4513; }
    .piece.selected{ transform:scale(1.2); box-shadow:0 0 15px gold; }

    .line{
      position:absolute; background-color:#8B4513; z-index:0; height:6px; transform-origin:0 50%;
      /* ✅ bağlantı çizgileri görünmez */
      opacity:0;
      pointer-events:none;
    }

    .controls{
      display:flex; justify-content:center; gap:15px; margin-top:20px; flex-wrap:wrap;
    }
    button{
      padding:12px 25px; background-color:#4CAF50; color:white; border:none; border-radius:50px;
      cursor:pointer; font-size:1rem; font-weight:bold; transition:all .3s ease;
      box-shadow:0 4px 6px rgba(0,0,0,0.1);
    }
    button:hover{ background-color:#45a049; transform:translateY(-2px); }
    button:disabled{ background-color:#cccccc; cursor:not-allowed; transform:none; }

    .difficulty {
      display:flex; align-items:center; gap:10px;
      background: rgba(255,255,255,0.15);
      padding:10px 14px;
      border-radius: 999px;
    }
    .difficulty label { font-weight:700; opacity:.9; }
    .difficulty select {
      padding:8px 10px;
      border-radius: 999px;
      border: none;
      outline: none;
      font-weight:700;
      cursor:pointer;
    }

    .message{
      margin-top:15px; padding:10px; background-color:rgba(255,255,255,0.2);
      border-radius:5px; font-weight:bold; min-height:24px;
    }

    .instructions{
      margin-top:20px; padding:15px; background-color:rgba(255,255,255,0.1);
      border-radius:10px; text-align:left; font-size:.9rem;
    }
    .instructions h3{ margin-bottom:10px; text-align:center; }
    .instructions ul{ padding-left:20px; }
    .instructions li{ margin-bottom:8px; }

    @media (max-width:600px){
      .board{ width:350px; height:350px; }
      .piece{ width:30px; height:30px; }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Tilki ve Kazlar Oyunu</h1>

    <div class="player-selection">
      <button class="player-btn active" id="playAsGeese">Kaz Olarak Oyna</button>
      <button class="player-btn" id="playAsFox">Tilki Olarak Oyna</button>
    </div>

    <div class="game-info">
      <div class="info-item">
        <div class="info-label">SIRA</div>
        <div class="info-value" id="turn">Kazlar</div>
      </div>
      <div class="info-item">
        <div class="info-label">KAZLAR</div>
        <div class="info-value" id="geeseCount">17</div>
      </div>
      <div class="info-item">
        <div class="info-label">HAREKET</div>
        <div class="info-value" id="moves">0</div>
      </div>
    </div>

    <div class="board-container">
      <div class="board" id="board"></div>
    </div>

    <div class="message" id="message">Kazlar oynuyor. Bir kaz seçin.</div>

    <div class="controls">
      <button id="restartBtn">Yeni Oyun</button>
      <button id="hintBtn">İpucu Göster</button>

      <div class="difficulty">
        <label for="difficultySelect">Zorluk</label>
        <select id="difficultySelect">
          <option value="2">Kolay</option>
          <option value="3" selected>Orta</option>
          <option value="4">Zor</option>
          <option value="5">Çok Zor</option>
        </select>
      </div>
    </div>

    <div class="instructions">
      <h3>Oyun Kuralları</h3>
      <ul>
       <li><strong>Kazlar (Beyaz):</strong> Kazlar her turda <strong>sadece 1 adım</strong> hareket eder. 
  <strong>Geri yönde</strong> (başlangıca doğru / yukarı doğru) hareket edemezler. 
  Buna karşılık, aynı seviyede <strong>sağa veya sola</strong> 1 adım gidebilirler (eğer o nokta geçerliyse ve boşsa). 
  Kazlar <strong>yeme hamlesi yapamaz</strong>.</li>

<li><strong>Tilki (Kırmızı):</strong> Tilki her turda komşu bir noktaya <strong>1 adım</strong> hareket edebilir. 
  Ayrıca “yeme” hamlesiyle bir kazı alarak ilerleyebilir: Tilki ile kaz komşu olmalı ve kazın hemen arkasındaki hedef nokta <strong>boş</strong> olmalıdır. 
  Bu durumda tilki kazın üzerinden atlar, kaz oyundan çıkar ve tilki boş hedef noktaya yerleşir.</li>

<li><strong>Bu sürümün özel kuralı:</strong> Tilki <strong>çapraz hareket edebilir</strong> (komşu çapraz noktaya 1 adım gidebilir). 
  Ancak tilki <strong>çapraz yiyemez</strong>: yeme hamlesi sadece <strong>düz yönde</strong> yapılır (yatay veya dikey). 
  Yani kaz tilkinin çaprazındaysa, tilki onu “üstünden atlayarak” yiyemez; kazın tilkinin <strong>sağında/solunda</strong> veya <strong>üstünde/altında</strong> olması gerekir.</li>

<li><strong>Kazanma Koşulları (Kazlar):</strong> Kazlar, tilkinin yapabileceği <strong>hiçbir geçerli hamle kalmayacak</strong> şekilde onu sıkıştırırsa oyunu kazanır.</li>

<li><strong>Kazanma Koşulları (Tilki):</strong> Tilki toplamda <strong>7 kaz</strong> yediğinde oyunu kazanır.</li>

      </ul>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {

      const VALID_CELLS = [
        [0,2],[0,3],[0,4],
        [1,2],[1,3],[1,4],
        [2,0],[2,1],[2,2],[2,3],[2,4],[2,5],[2,6],
        [3,0],[3,1],[3,2],[3,3],[3,4],[3,5],[3,6],
        [4,0],[4,1],[4,2],[4,3],[4,4],[4,5],[4,6],
        [5,2],[5,3],[5,4],
        [6,2],[6,3],[6,4]
      ];

      const BOARD_SIZE = 7;

      // (KAZLAR için) Orijinal bağlantılar
      const CONNECTIONS = {
        '0,2': ['0,3','1,2','1,3'],
        '0,3': ['0,2','0,4','1,3'],
        '0,4': ['0,3','1,3','1,4'],

        '1,2': ['0,2','1,3','2,1','2,2'],
        '1,3': ['0,2','0,3','0,4','1,2','1,4','2,2','2,3','2,4'],
        '1,4': ['0,3','0,4','1,3','2,4','2,5'],

        '2,0': ['2,1','3,0','3,1'],
        '2,1': ['1,2','2,0','2,2','3,1'],
        '2,2': ['1,2','1,3','2,1','2,3','3,2'],
        '2,3': ['1,3','2,2','2,4','3,3'],
        '2,4': ['1,3','1,4','2,3','2,5','3,4'],
        '2,5': ['1,4','2,4','2,6','3,5'],
        '2,6': ['2,5','3,5','3,6'],

        '3,0': ['2,0','3,1','4,0'],
        '3,1': ['2,0','2,1','3,0','3,2','4,1'],
        '3,2': ['2,2','3,1','3,3','4,2'],
        '3,3': ['2,3','3,2','3,4','4,3'],
        '3,4': ['2,4','3,3','3,5','4,4'],
        '3,5': ['2,5','3,4','3,6','4,5'],
        '3,6': ['2,6','3,5','4,6'],

        '4,0': ['3,0','4,1','5,0'],
        '4,1': ['3,1','4,0','4,2','5,1'],
        '4,2': ['3,2','4,1','4,3','5,2'],
        '4,3': ['3,3','4,2','4,4','5,3'],
        '4,4': ['3,4','4,3','4,5','5,4'],
        '4,5': ['3,5','4,4','4,6','5,5'],
        '4,6': ['3,6','4,5','5,6'],

        '5,2': ['4,2','5,3','6,2'],
        '5,3': ['4,3','5,2','5,4','6,3'],
        '5,4': ['4,4','5,3','6,4'],

        '6,2': ['5,2','6,3'],
        '6,3': ['5,3','6,2','6,4'],
        '6,4': ['5,4','6,3']
      };

      function isValidCell(r, c) {
        return VALID_CELLS.some(([vr, vc]) => vr === r && vc === c);
      }

      // ✅ Kazın "geri" hamlesini kesin engelleyen kontrol
      function isGooseStepAllowed(fromRow, fromCol, toRow, toCol) {
        const dr = toRow - fromRow;
        const dc = toCol - fromCol;

        if (dr < 0) return false;                       // geri yasak
        if (Math.abs(dr) > 1 || Math.abs(dc) > 1) return false; // 1 adım
        if (dr === 0 && dc === 0) return false;

        // yan/ileri/çapraz serbest (dr: 0/1)
        return true;
      }

      // ✅ Tilki yeme yön filtresi: sadece düz
      function isFoxCaptureDirectionAllowed(dr, dc) {
        // (±1,0) veya (0,±1)
        return (Math.abs(dr) + Math.abs(dc)) === 1;
      }

      function buildSafeConnections(raw) {
        const safe = {};

        Object.keys(raw).forEach(from => {
          const [r, c] = from.split(',').map(Number);
          if (!isValidCell(r, c)) return;

          const filtered = raw[from]
            .map(s => s.trim())
            .filter(to => {
              const [tr, tc] = to.split(',').map(Number);
              return isValidCell(tr, tc);
            });

          safe[from] = filtered;
        });

        // simetrik yap
        Object.keys(safe).forEach(from => {
          safe[from].forEach(to => {
            if (!safe[to]) safe[to] = [];
            if (!safe[to].includes(from)) safe[to].push(from);
          });
        });

        return safe;
      }

      const SAFE_CONNECTIONS = buildSafeConnections(CONNECTIONS);

      // ✅ Tilki için: tüm geçerli noktalarda 8-yön (king move) bağlantı üret
      function buildFoxConnectionsAllDiagonals() {
        const fox = {};
        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            if (!isValidCell(r, c)) continue;
            const key = `${r},${c}`;
            fox[key] = [];

            for (let dr = -1; dr <= 1; dr++) {
              for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const nr = r + dr;
                const nc = c + dc;
                if (!isValidCell(nr, nc)) continue;
                fox[key].push(`${nr},${nc}`);
              }
            }
          }
        }
        return fox;
      }

      const FOX_CONNECTIONS = buildFoxConnectionsAllDiagonals();

      const gameState = {
        board: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null)),
        selectedPiece: null,
        currentPlayer: 'geese',
        validMoves: [],
        moves: 0,
        geeseCount: 17,
        gameOver: false,
        playerSide: 'geese',
        capturedGeese: 0
      };

      // DOM
      const boardEl = document.getElementById('board');
      const turnEl = document.getElementById('turn');
      const geeseCountEl = document.getElementById('geeseCount');
      const movesEl = document.getElementById('moves');
      const messageEl = document.getElementById('message');
      const restartBtn = document.getElementById('restartBtn');
      const hintBtn = document.getElementById('hintBtn');
      const playAsGeeseBtn = document.getElementById('playAsGeese');
      const playAsFoxBtn = document.getElementById('playAsFox');
      const difficultySelect = document.getElementById('difficultySelect');

      let AI_DEPTH = parseInt(difficultySelect.value, 10);

      difficultySelect.addEventListener('change', () => {
        AI_DEPTH = parseInt(difficultySelect.value, 10);
        messageEl.textContent = `Zorluk güncellendi: ${difficultySelect.options[difficultySelect.selectedIndex].text}`;
      });

      playAsGeeseBtn.addEventListener('click', function () {
        gameState.playerSide = 'geese';
        playAsGeeseBtn.classList.add('active');
        playAsFoxBtn.classList.remove('active');
        initializeGame();
      });

      playAsFoxBtn.addEventListener('click', function () {
        gameState.playerSide = 'fox';
        playAsFoxBtn.classList.add('active');
        playAsGeeseBtn.classList.remove('active');
        initializeGame();
      });

      function initializeGame() {
        gameState.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));
        gameState.selectedPiece = null;
        gameState.validMoves = [];
        gameState.moves = 0;
        gameState.geeseCount = 17;
        gameState.gameOver = false;
        gameState.currentPlayer = 'geese';
        gameState.capturedGeese = 0;

        // 17 kaz
        const geesePositions = [
          [0,2],[0,3],[0,4],
          [1,2],[1,3],[1,4],
          [2,0],[2,1],[2,2],[2,3],[2,4],[2,5],[2,6],
          [3,0],[3,6],
          [4,0],[4,6]
        ];
        geesePositions.forEach(([row, col]) => {
          gameState.board[row][col] = 'goose';
        });

        // tilki merkez
        gameState.board[3][3] = 'fox';

        updateUI();
        renderBoard();
        drawLines();   // çizgiler çizilir ama CSS ile görünmez
        updateMessage();

        if (gameState.playerSide === 'fox' && gameState.currentPlayer === 'geese' && !gameState.gameOver) {
          setTimeout(computerMove, 400);
        }
      }

      function renderBoard() {
        boardEl.innerHTML = '';

        for (let row = 0; row < BOARD_SIZE; row++) {
          for (let col = 0; col < BOARD_SIZE; col++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.row = row;
            cell.dataset.col = col;

            const active = isValidCell(row, col);
            if (active) {
              cell.classList.add('active');

              if (gameState.selectedPiece &&
                  gameState.selectedPiece.row === row &&
                  gameState.selectedPiece.col === col) {
                cell.classList.add('highlight');
              }

              const validMove = gameState.validMoves.find(m => m.row === row && m.col === col);
              if (validMove) {
                cell.classList.add(validMove.capture ? 'capture' : 'valid');
              }

              const pieceType = gameState.board[row][col];
              if (pieceType) {
                const piece = document.createElement('div');
                piece.className = `piece ${pieceType}`;
                cell.appendChild(piece);
              }

              cell.addEventListener('click', () => handleCellClick(row, col));
            }

            boardEl.appendChild(cell);
          }
        }
      }

      // çizgiler: kaz bağlantılarına göre çizilir (görünmez)
      function drawLines() {
        const drawn = new Set();
        const cellSize = boardEl.offsetWidth / BOARD_SIZE;

        Object.keys(SAFE_CONNECTIONS).forEach(from => {
          SAFE_CONNECTIONS[from].forEach(to => {
            const key = [from, to].sort().join('|');
            if (drawn.has(key)) return;
            drawn.add(key);

            const [r1, c1] = from.split(',').map(Number);
            const [r2, c2] = to.split(',').map(Number);

            const x1 = (c1 + 0.5) * cellSize;
            const y1 = (r1 + 0.5) * cellSize;
            const x2 = (c2 + 0.5) * cellSize;
            const y2 = (r2 + 0.5) * cellSize;

            const length = Math.hypot(x2 - x1, y2 - y1);
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

            const lineEl = document.createElement('div');
            lineEl.className = 'line';
            lineEl.style.width = `${length}px`;
            lineEl.style.left = `${x1}px`;
            lineEl.style.top = `${y1}px`;
            lineEl.style.transform = `rotate(${angle}deg) translateY(-50%)`;

            boardEl.appendChild(lineEl);
          });
        });
      }

      function handleCellClick(row, col) {
        if (gameState.gameOver) return;
        if (!isValidCell(row, col)) return;

        // oyuncu sırası değilse tıklama yok
        if ((gameState.playerSide === 'geese' && gameState.currentPlayer === 'fox') ||
            (gameState.playerSide === 'fox' && gameState.currentPlayer === 'geese')) {
          return;
        }

        const cellValue = gameState.board[row][col];

        if (!gameState.selectedPiece) {
          if ((gameState.currentPlayer === 'geese' && cellValue === 'goose') ||
              (gameState.currentPlayer === 'fox' && cellValue === 'fox')) {
            gameState.selectedPiece = { row, col };
            gameState.validMoves = getValidMoves(row, col);
            renderBoard();
            updateMessage();
          }
          return;
        }

        const move = gameState.validMoves.find(m => m.row === row && m.col === col);
        if (!move) {
          gameState.selectedPiece = null;
          gameState.validMoves = [];
          renderBoard();
          updateMessage();
          return;
        }

        movePiece(gameState.selectedPiece.row, gameState.selectedPiece.col, row, col);

        if (move.capture) {
          gameState.board[move.capture.row][move.capture.col] = null;
          gameState.geeseCount--;
          gameState.capturedGeese++;

          checkGameState();
          if (gameState.gameOver) {
            renderBoard();
            updateUI();
            return;
          }

          // tilki zincir zıplayabilir (insan oynuyorsa)
          if (gameState.currentPlayer === 'fox') {
            const moreCaps = getValidMoves(row, col).filter(m => m.capture);
            if (moreCaps.length > 0) {
              gameState.selectedPiece = { row, col };
              gameState.validMoves = moreCaps;
              renderBoard();
              messageEl.textContent = "Tilki tekrar zıplayabilir! Başka bir kaz yiyebilir.";
              return;
            }
          }
        }

        gameState.selectedPiece = null;
        gameState.validMoves = [];

        checkGameState();
        if (gameState.gameOver) {
          renderBoard();
          updateUI();
          return;
        }

        gameState.currentPlayer = gameState.currentPlayer === 'geese' ? 'fox' : 'geese';
        gameState.moves++;

        renderBoard();
        updateUI();
        updateMessage();

        if (((gameState.playerSide === 'geese' && gameState.currentPlayer === 'fox') ||
             (gameState.playerSide === 'fox' && gameState.currentPlayer === 'geese')) &&
            !gameState.gameOver) {
          setTimeout(computerMove, 250);
        }
      }

      function getValidMoves(row, col) {
        const piece = gameState.board[row][col];
        const moves = [];
        const key = `${row},${col}`;

        if (piece === 'goose') {
          if (!SAFE_CONNECTIONS[key]) return moves;
          SAFE_CONNECTIONS[key].forEach(conn => {
            const [nr, nc] = conn.split(',').map(Number);
            if (!isGooseStepAllowed(row, col, nr, nc)) return;
            if (gameState.board[nr][nc] !== null) return;
            moves.push({ row: nr, col: nc });
          });
          return moves;
        }

        if (piece === 'fox') {
          // ✅ Tilki her noktada çapraz/düz 1 adım gidebilir
          if (!FOX_CONNECTIONS[key]) return moves;

          FOX_CONNECTIONS[key].forEach(conn => {
            const [nr, nc] = conn.split(',').map(Number);

            // normal adım
            if (gameState.board[nr][nc] === null) {
              moves.push({ row: nr, col: nc });
              return;
            }

            // yakalama: komşu kaz ise, aynı yönde bir adım daha
            if (gameState.board[nr][nc] === 'goose') {
              const dr = nr - row;
              const dc = nc - col;

              // ✅ çapraz yeme KAPALI: sadece düz yönde yakala
              if (!isFoxCaptureDirectionAllowed(dr, dc)) return;

              const jr = nr + dr;
              const jc = nc + dc;

              if (!isValidCell(jr, jc)) return;
              if (gameState.board[jr][jc] !== null) return;

              const jumpFromKey = `${nr},${nc}`;
              const targetKey = `${jr},${jc}`;

              // iki adımlı yol da tilki bağlantılarında olmalı
              if (FOX_CONNECTIONS[jumpFromKey] && FOX_CONNECTIONS[jumpFromKey].includes(targetKey)) {
                moves.push({ row: jr, col: jc, capture: { row: nr, col: nc } });
              }
            }
          });

          return moves;
        }

        return moves;
      }

      function movePiece(fromRow, fromCol, toRow, toCol) {
        const piece = gameState.board[fromRow][fromCol];
        gameState.board[toRow][toCol] = piece;
        gameState.board[fromRow][fromCol] = null;
      }

      // ===========================
      // MINIMAX + ALPHA-BETA
      // ===========================
      const WIN_SCORE = 1e9;
      const LOSE_SCORE = -1e9;

      function cloneForAI(gs) {
        return {
          board: gs.board.map(r => r.slice()),
          currentPlayer: gs.currentPlayer,
          geeseCount: gs.geeseCount,
          capturedGeese: gs.capturedGeese
        };
      }

      function findFoxOn(board) {
        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            if (board[r][c] === 'fox') return { row: r, col: c };
          }
        }
        return null;
      }

      function getValidMovesOnState(gs, row, col) {
        const piece = gs.board[row][col];
        const moves = [];
        const key = `${row},${col}`;

        if (piece === 'goose') {
          if (!SAFE_CONNECTIONS[key]) return moves;
          SAFE_CONNECTIONS[key].forEach(conn => {
            const [nr, nc] = conn.split(',').map(Number);
            if (!isGooseStepAllowed(row, col, nr, nc)) return;
            if (gs.board[nr][nc] !== null) return;
            moves.push({ row: nr, col: nc });
          });
          return moves;
        }

        if (piece === 'fox') {
          if (!FOX_CONNECTIONS[key]) return moves;

          FOX_CONNECTIONS[key].forEach(conn => {
            const [nr, nc] = conn.split(',').map(Number);

            if (gs.board[nr][nc] === null) {
              moves.push({ row: nr, col: nc });
              return;
            }

            if (gs.board[nr][nc] === 'goose') {
              const dr = nr - row;
              const dc = nc - col;

              // ✅ AI için de çapraz yeme KAPALI
              if (!isFoxCaptureDirectionAllowed(dr, dc)) return;

              const jr = nr + dr;
              const jc = nc + dc;

              if (!isValidCell(jr, jc)) return;
              if (gs.board[jr][jc] !== null) return;

              const jumpFromKey = `${nr},${nc}`;
              const targetKey = `${jr},${jc}`;

              if (FOX_CONNECTIONS[jumpFromKey] && FOX_CONNECTIONS[jumpFromKey].includes(targetKey)) {
                moves.push({ row: jr, col: jc, capture: { row: nr, col: nc } });
              }
            }
          });

          return moves;
        }

        return moves;
      }

      function terminalScoreAI(gs) {
        if (gs.capturedGeese >= 7) return WIN_SCORE;

        const fox = findFoxOn(gs.board);
        if (!fox) return LOSE_SCORE;

        const foxMoves = getValidMovesOnState(gs, fox.row, fox.col);
        if (foxMoves.length === 0) return LOSE_SCORE;

        return null;
      }

      function evaluateAI(gs) {
        const t = terminalScoreAI(gs);
        if (t !== null) return t;

        const fox = findFoxOn(gs.board);
        const foxMob = fox ? getValidMovesOnState(gs, fox.row, fox.col).length : 0;

        let geeseAdvance = 0;
        let geeseMob = 0;

        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            if (gs.board[r][c] === 'goose') {
              geeseAdvance += r;
              geeseMob += getValidMovesOnState(gs, r, c).length;
            }
          }
        }

        const W_CAPTURE = 120;
        const W_FOX_MOB = 8;
        const W_GEESE_ADV = 1.3;
        const W_GEESE_MOB = 1.5;

        return (gs.capturedGeese * W_CAPTURE)
             + (foxMob * W_FOX_MOB)
             - (geeseAdvance * W_GEESE_ADV)
             - (geeseMob * W_GEESE_MOB);
      }

      function generateAllMovesAI(gs, player) {
        const moves = [];
        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            const p = gs.board[r][c];
            if ((player === 'geese' && p === 'goose') || (player === 'fox' && p === 'fox')) {
              const vm = getValidMovesOnState(gs, r, c);
              vm.forEach(m => moves.push({ from: { row: r, col: c }, to: m }));
            }
          }
        }

        // tilki yakalamayı tercih et
        if (player === 'fox') {
          const caps = moves.filter(x => x.to.capture);
          if (caps.length > 0) return caps;
        }

        return moves;
      }

      function applyMoveAI(gs, move) {
        const ns = cloneForAI(gs);
        const piece = ns.board[move.from.row][move.from.col];

        ns.board[move.to.row][move.to.col] = piece;
        ns.board[move.from.row][move.from.col] = null;

        if (move.to.capture) {
          ns.board[move.to.capture.row][move.to.capture.col] = null;
          ns.geeseCount--;
          ns.capturedGeese++;
        }

        if (piece === 'fox' && move.to.capture) {
          const moreCaps = getValidMovesOnState(ns, move.to.row, move.to.col).filter(m => m.capture);
          if (moreCaps.length > 0) {
            ns.currentPlayer = 'fox';
            return ns;
          }
        }

        ns.currentPlayer = (gs.currentPlayer === 'geese') ? 'fox' : 'geese';
        return ns;
      }

      function alphabeta(gs, depth, alpha, beta) {
        const term = terminalScoreAI(gs);
        if (term !== null) return term;
        if (depth === 0) return evaluateAI(gs);

        const player = gs.currentPlayer;
        const moves = generateAllMovesAI(gs, player);
        if (moves.length === 0) return (player === 'fox') ? LOSE_SCORE : evaluateAI(gs);

        if (player === 'fox') {
          let best = -Infinity;
          for (const m of moves) {
            const val = alphabeta(applyMoveAI(gs, m), depth - 1, alpha, beta);
            best = Math.max(best, val);
            alpha = Math.max(alpha, best);
            if (beta <= alpha) break;
          }
          return best;
        } else {
          let best = Infinity;
          for (const m of moves) {
            const val = alphabeta(applyMoveAI(gs, m), depth - 1, alpha, beta);
            best = Math.min(best, val);
            beta = Math.min(beta, best);
            if (beta <= alpha) break;
          }
          return best;
        }
      }

      function chooseBestMoveAI(gs, depth) {
        const player = gs.currentPlayer;
        const moves = generateAllMovesAI(gs, player);
        if (moves.length === 0) return null;

        let bestMove = moves[0];
        let bestScore = (player === 'fox') ? -Infinity : Infinity;

        for (const m of moves) {
          const ns = applyMoveAI(gs, m);
          const score = alphabeta(ns, depth - 1, -Infinity, Infinity);

          if (player === 'fox') {
            if (score > bestScore) { bestScore = score; bestMove = m; }
          } else {
            if (score < bestScore) { bestScore = score; bestMove = m; }
          }
        }
        return bestMove;
      }

      function computerMove() {
        if (gameState.gameOver) return;

        const best = chooseBestMoveAI(gameState, AI_DEPTH);
        if (!best) {
          checkGameState();
          updateUI();
          renderBoard();
          updateMessage();
          return;
        }

        movePiece(best.from.row, best.from.col, best.to.row, best.to.col);

        if (best.to.capture) {
          gameState.board[best.to.capture.row][best.to.capture.col] = null;
          gameState.geeseCount--;
          gameState.capturedGeese++;

          checkGameState();
          if (gameState.gameOver) {
            updateUI(); renderBoard();
            return;
          }

          if (gameState.currentPlayer === 'fox') {
            const moreCaps = getValidMoves(best.to.row, best.to.col).filter(m => m.capture);
            updateUI(); renderBoard(); updateMessage();
            if (!gameState.gameOver && moreCaps.length > 0) {
              setTimeout(computerMove, 180);
              return;
            }
          }
        }

        checkGameState();

        if (!gameState.gameOver) {
          gameState.currentPlayer = (gameState.currentPlayer === 'geese') ? 'fox' : 'geese';
          gameState.moves++;
        }

        updateUI();
        renderBoard();
        updateMessage();

        if (!gameState.gameOver &&
            ((gameState.playerSide === 'geese' && gameState.currentPlayer === 'fox') ||
             (gameState.playerSide === 'fox' && gameState.currentPlayer === 'geese'))) {
          setTimeout(computerMove, 220);
        }
      }

      function checkGameState() {
        if (gameState.capturedGeese >= 7) {
          gameState.gameOver = true;
          messageEl.textContent = "Tilki kazandı! 7 kaz yedi.";
          return;
        }

        const foxPos = findFoxOn(gameState.board);
        if (!foxPos) return;

        const foxMoves = getValidMoves(foxPos.row, foxPos.col);
        if (foxMoves.length === 0) {
          gameState.gameOver = true;
          messageEl.textContent = "Kazlar kazandı! Tilkiyi sıkıştırdılar.";
        }
      }

      function updateUI() {
        turnEl.textContent = (gameState.currentPlayer === 'geese') ? 'Kazlar' : 'Tilki';
        geeseCountEl.textContent = gameState.geeseCount;
        movesEl.textContent = gameState.moves;
      }

      function updateMessage() {
        if (gameState.gameOver) return;

        if (gameState.selectedPiece) {
          messageEl.textContent = "Bir hedef hücre seçin.";
          return;
        }

        const playerTurn =
          (gameState.playerSide === 'geese' && gameState.currentPlayer === 'geese') ||
          (gameState.playerSide === 'fox' && gameState.currentPlayer === 'fox');

        if (playerTurn) {
          messageEl.textContent =
            (gameState.currentPlayer === 'geese')
              ? "Sıra sizde. Bir kaz seçin."
              : "Sıra sizde. Tilkiyi hareket ettirin.";
        } else {
          messageEl.textContent =
            (gameState.currentPlayer === 'geese')
              ? "Bilgisayar (Kazlar) düşünüyor..."
              : "Bilgisayar (Tilki) düşünüyor...";
        }
      }

      function showHint() {
        if (gameState.gameOver || gameState.selectedPiece) return;

        if ((gameState.playerSide === 'geese' && gameState.currentPlayer === 'fox') ||
            (gameState.playerSide === 'fox' && gameState.currentPlayer === 'geese')) {
          messageEl.textContent = "Şu anda sıra sizde değil.";
          return;
        }

        let allMoves = [];
        for (let r = 0; r < BOARD_SIZE; r++) {
          for (let c = 0; c < BOARD_SIZE; c++) {
            const p = gameState.board[r][c];
            if ((gameState.currentPlayer === 'geese' && p === 'goose') ||
                (gameState.currentPlayer === 'fox' && p === 'fox')) {
              const moves = getValidMoves(r, c);
              moves.forEach(m => allMoves.push({ from: { row: r, col: c }, to: m }));
            }
          }
        }

        if (allMoves.length === 0) {
          messageEl.textContent = "İpucu: Hiç hamle bulunamadı.";
          return;
        }

        const hint = allMoves[Math.floor(Math.random() * allMoves.length)];
        gameState.selectedPiece = hint.from;
        gameState.validMoves = [hint.to];
        renderBoard();
        messageEl.textContent = "İpucu: İşaretli hücreye hareket edebilirsiniz.";
      }

      restartBtn.addEventListener('click', initializeGame);
      hintBtn.addEventListener('click', showHint);

      initializeGame();
    });
  </script>
</body>
</html>
<!-- test -->